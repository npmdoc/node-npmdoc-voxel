<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/maxogden/voxel"

    >voxel (v0.5.0)</a>
</h1>
<h4>tools to work with voxel generation and chunking in javascript</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.voxel">module voxel</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.voxel">
            function <span class="apidocSignatureSpan"></span>voxel
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.Chunker">
            function <span class="apidocSignatureSpan">voxel.</span>Chunker
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.chunker">
            function <span class="apidocSignatureSpan">voxel.</span>chunker
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.generate">
            function <span class="apidocSignatureSpan">voxel.</span>generate
            <span class="apidocSignatureSpan">(lo, hi, fn, game)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.generateExamples">
            function <span class="apidocSignatureSpan">voxel.</span>generateExamples
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.scale">
            function <span class="apidocSignatureSpan">voxel.</span>scale
            <span class="apidocSignatureSpan">( x, fromLow, fromHigh, toLow, toHigh )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">voxel.</span>Chunker.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">voxel.</span>culled</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">voxel.</span>generator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">voxel.</span>geometry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">voxel.</span>greedy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">voxel.</span>meshers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">voxel.</span>monotone</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">voxel.</span>stupid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">voxel.</span>transgreedy</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.voxel.Chunker">module voxel.Chunker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.Chunker.Chunker">
            function <span class="apidocSignatureSpan">voxel.</span>Chunker
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.Chunker.super">
            function <span class="apidocSignatureSpan">voxel.Chunker.</span>super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.voxel.Chunker.prototype">module voxel.Chunker.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.Chunker.prototype.chunkAtCoordinates">
            function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>chunkAtCoordinates
            <span class="apidocSignatureSpan">(x, y, z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.Chunker.prototype.chunkAtPosition">
            function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>chunkAtPosition
            <span class="apidocSignatureSpan">(position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.Chunker.prototype.generateChunk">
            function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>generateChunk
            <span class="apidocSignatureSpan">(x, y, z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.Chunker.prototype.getBounds">
            function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>getBounds
            <span class="apidocSignatureSpan">(x, y, z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.Chunker.prototype.nearbyChunks">
            function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>nearbyChunks
            <span class="apidocSignatureSpan">(position, distance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.Chunker.prototype.requestMissingChunks">
            function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>requestMissingChunks
            <span class="apidocSignatureSpan">(position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.Chunker.prototype.voxelAtCoordinates">
            function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>voxelAtCoordinates
            <span class="apidocSignatureSpan">(x, y, z, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.Chunker.prototype.voxelAtPosition">
            function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>voxelAtPosition
            <span class="apidocSignatureSpan">(pos, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.Chunker.prototype.voxelIndexFromCoordinates">
            function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>voxelIndexFromCoordinates
            <span class="apidocSignatureSpan">(x, y, z)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.voxel.chunker">module voxel.chunker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.chunker.chunker">
            function <span class="apidocSignatureSpan">voxel.</span>chunker
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.chunker.Chunker">
            function <span class="apidocSignatureSpan">voxel.chunker.</span>Chunker
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.voxel.culled">module voxel.culled</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.culled.mesher">
            function <span class="apidocSignatureSpan">voxel.culled.</span>mesher
            <span class="apidocSignatureSpan">(volume, dims)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.voxel.generator">module voxel.generator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.generator.Checker">
            function <span class="apidocSignatureSpan">voxel.generator.</span>Checker
            <span class="apidocSignatureSpan">(i, j, k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.generator.Hill">
            function <span class="apidocSignatureSpan">voxel.generator.</span>Hill
            <span class="apidocSignatureSpan">(i, j, k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.generator.Noise">
            function <span class="apidocSignatureSpan">voxel.generator.</span>Noise
            <span class="apidocSignatureSpan">(i, j, k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.generator.Sphere">
            function <span class="apidocSignatureSpan">voxel.generator.</span>Sphere
            <span class="apidocSignatureSpan">(i, j, k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.generator.Valley">
            function <span class="apidocSignatureSpan">voxel.generator.</span>Valley
            <span class="apidocSignatureSpan">(i, j, k)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.voxel.greedy">module voxel.greedy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.greedy.mesher">
            function <span class="apidocSignatureSpan">voxel.greedy.</span>mesher
            <span class="apidocSignatureSpan">(volume, dims)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.voxel.meshers">module voxel.meshers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.meshers.culled">
            function <span class="apidocSignatureSpan">voxel.meshers.</span>culled
            <span class="apidocSignatureSpan">(volume, dims)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.meshers.greedy">
            function <span class="apidocSignatureSpan">voxel.meshers.</span>greedy
            <span class="apidocSignatureSpan">(volume, dims)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.meshers.monotone">
            function <span class="apidocSignatureSpan">voxel.meshers.</span>monotone
            <span class="apidocSignatureSpan">(volume, dims)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.meshers.stupid">
            function <span class="apidocSignatureSpan">voxel.meshers.</span>stupid
            <span class="apidocSignatureSpan">(volume, dims)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.meshers.transgreedy">
            function <span class="apidocSignatureSpan">voxel.meshers.</span>transgreedy
            <span class="apidocSignatureSpan">(volume, dims, mesherExtraData)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.voxel.monotone">module voxel.monotone</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.monotone.mesher">
            function <span class="apidocSignatureSpan">voxel.monotone.</span>mesher
            <span class="apidocSignatureSpan">(volume, dims)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.voxel.stupid">module voxel.stupid</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.stupid.mesher">
            function <span class="apidocSignatureSpan">voxel.stupid.</span>mesher
            <span class="apidocSignatureSpan">(volume, dims)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.voxel.transgreedy">module voxel.transgreedy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.voxel.transgreedy.mesher">
            function <span class="apidocSignatureSpan">voxel.transgreedy.</span>mesher
            <span class="apidocSignatureSpan">(volume, dims, mesherExtraData)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voxel" id="apidoc.module.voxel">module voxel</a></h1>


    <h2>
        <a href="#apidoc.element.voxel.voxel" id="apidoc.element.voxel.voxel">
        function <span class="apidocSignatureSpan"></span>voxel
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">voxel = function (opts) {
  if (!opts.generateVoxelChunk) opts.generateVoxelChunk = function(low, high) {
    return generate(low, high, module.exports.generator[&#x27;Valley&#x27;])
  }
  return chunker(opts)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.Chunker" id="apidoc.element.voxel.Chunker">
        function <span class="apidocSignatureSpan">voxel.</span>Chunker
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chunker(opts) {
  this.distance = opts.chunkDistance || 2
  this.chunkSize = opts.chunkSize || 32
  this.chunkPad = opts.chunkPad !== undefined ? opts.chunkPad : 0
  this.cubeSize = opts.cubeSize || 25
  this.generateVoxelChunk = opts.generateVoxelChunk
  this.chunks = {}
  this.meshes = {}

  if (this.chunkSize &#x26; this.chunkSize-1 !== 0)
    throw new Error(&#x27;chunkSize must be a power of 2&#x27;)
  var bits = 0;
  for (var size = this.chunkSize; size &#x3e; 0; size &#x3e;&#x3e;= 1) bits++;
  this.chunkBits = bits - 1;
  this.chunkMask = (1 &#x3c;&#x3c; this.chunkBits) - 1
  this.chunkPadHalf = this.chunkPad &#x3e;&#x3e; 1
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.chunker" id="apidoc.element.voxel.chunker">
        function <span class="apidocSignatureSpan">voxel.</span>chunker
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chunker = function (opts) {
  return new Chunker(opts)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.generate" id="apidoc.element.voxel.generate">
        function <span class="apidocSignatureSpan">voxel.</span>generate
        <span class="apidocSignatureSpan">(lo, hi, fn, game)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generate(lo, hi, fn, game) {
  // To fix the display gaps, we need to pad the bounds
  lo[0]--
  lo[1]--
  lo[2]--
  hi[0]++
  hi[1]++
  hi[2]++
  var dims = [hi[2]-lo[2], hi[1]-lo[1], hi[0]-lo[0]]
  var data = ndarray(new Uint16Array(dims[2] * dims[1] * dims[0]), dims)
  for (var k = lo[2]; k &#x3c; hi[2]; k++)
    for (var j = lo[1]; j &#x3c; hi[1]; j++)
      for(var i = lo[0]; i &#x3c; hi[0]; i++) {
        data.set(k-lo[2], j-lo[1], i-lo[0], fn(i, j, k))
      }
  return data
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```
in a browser:

use `voxel-browser.js`

# usage

## require(&#x27;voxel&#x27;).<span class="apidocCodeKeywordSpan">generate</span>(low, high, iterator)

where `low` and `high` are `[x, y, z]` start and end positions to iterate over and `iterator` is the function that visits each voxel

returns an object like this: `{ &#x22;voxels&#x22;: &#x22;a 1D Int32Array filled with voxel data&#x22;, &#x22;dims&#x22;: [x, y,
z] }`

example that creates randomly colored voxels:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.generateExamples" id="apidoc.element.voxel.generateExamples">
        function <span class="apidocSignatureSpan">voxel.</span>generateExamples
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateExamples = function () {
  return {
    &#x27;Sphere&#x27;: generate([-16,-16,-16], [16,16,16], module.exports.generator[&#x27;Sphere&#x27;]),
    &#x27;Noise&#x27;: generate([0,0,0], [16,16,16], module.exports.generator[&#x27;Noise&#x27;]),
    &#x27;Dense Noise&#x27;: generate([0,0,0], [16,16,16], module.exports.generator[&#x27;Dense Noise&#x27;]),
    &#x27;Checker&#x27;: generate([0,0,0], [8,8,8], module.exports.generator[&#x27;Checker&#x27;]),
    &#x27;Hill&#x27;: generate([-16, 0, -16], [16,16,16], module.exports.generator[&#x27;Hill&#x27;]),
    &#x27;Valley&#x27;: generate([0,0,0], [32,32,32], module.exports.generator[&#x27;Valley&#x27;]),
    &#x27;Hilly Terrain&#x27;: generate([0, 0, 0], [32,32,32], module.exports.generator[&#x27;Hilly Terrain&#x27;])
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

`meshers` is an object with `stupid`, `culled`, `monotone` and `greedy` mesher functions. you probably want to just use `greedy`.
all mesher functions accept voxel data in the format the gets returned by the `generate` function.

## require(&#x27;voxel&#x27;).generator

an object that contains a bunch of voxel generation functions to play with, from http://mikolalysenko.github.com/MinecraftMeshes2
/

## require(&#x27;voxel&#x27;).<span class="apidocCodeKeywordSpan">generateExamples</span>()

returns an object that contains a bunch of pre-generated voxel geometries to play with, from http://mikolalysenko.github.com/MinecraftMeshes2
/

# license

MIT
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.scale" id="apidoc.element.voxel.scale">
        function <span class="apidocSignatureSpan">voxel.</span>scale
        <span class="apidocSignatureSpan">( x, fromLow, fromHigh, toLow, toHigh )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scale = function ( x, fromLow, fromHigh, toLow, toHigh ) {
  return ( x - fromLow ) * ( toHigh - toLow ) / ( fromHigh - fromLow ) + toLow
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voxel.Chunker" id="apidoc.module.voxel.Chunker">module voxel.Chunker</a></h1>


    <h2>
        <a href="#apidoc.element.voxel.Chunker.Chunker" id="apidoc.element.voxel.Chunker.Chunker">
        function <span class="apidocSignatureSpan">voxel.</span>Chunker
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chunker(opts) {
  this.distance = opts.chunkDistance || 2
  this.chunkSize = opts.chunkSize || 32
  this.chunkPad = opts.chunkPad !== undefined ? opts.chunkPad : 0
  this.cubeSize = opts.cubeSize || 25
  this.generateVoxelChunk = opts.generateVoxelChunk
  this.chunks = {}
  this.meshes = {}

  if (this.chunkSize &#x26; this.chunkSize-1 !== 0)
    throw new Error(&#x27;chunkSize must be a power of 2&#x27;)
  var bits = 0;
  for (var size = this.chunkSize; size &#x3e; 0; size &#x3e;&#x3e;= 1) bits++;
  this.chunkBits = bits - 1;
  this.chunkMask = (1 &#x3c;&#x3c; this.chunkBits) - 1
  this.chunkPadHalf = this.chunkPad &#x3e;&#x3e; 1
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.Chunker.super" id="apidoc.element.voxel.Chunker.super">
        function <span class="apidocSignatureSpan">voxel.Chunker.</span>super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voxel.Chunker.prototype" id="apidoc.module.voxel.Chunker.prototype">module voxel.Chunker.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.voxel.Chunker.prototype.chunkAtCoordinates" id="apidoc.element.voxel.Chunker.prototype.chunkAtCoordinates">
        function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>chunkAtCoordinates
        <span class="apidocSignatureSpan">(x, y, z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chunkAtCoordinates = function (x, y, z) {
  var bits = this.chunkBits;
  var cx = x &#x3e;&#x3e; bits;
  var cy = y &#x3e;&#x3e; bits;
  var cz = z &#x3e;&#x3e; bits;
  var chunkPos = [cx, cy, cz];
  return chunkPos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Chunker.prototype.chunkAtPosition = function(position) {
  var cubeSize = this.cubeSize;
  var x = Math.floor(position[0] / cubeSize)
  var y = Math.floor(position[1] / cubeSize)
  var z = Math.floor(position[2] / cubeSize)
  var chunkPos = this.<span class="apidocCodeKeywordSpan">chunkAtCoordinates</span>(x, y, z)
  return chunkPos
};

Chunker.prototype.voxelIndexFromCoordinates = function(x, y, z) {
  throw new Error(&#x27;Chunker.prototype.voxelIndexFromCoordinates removed, use voxelAtCoordinates&#x27;)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.Chunker.prototype.chunkAtPosition" id="apidoc.element.voxel.Chunker.prototype.chunkAtPosition">
        function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>chunkAtPosition
        <span class="apidocSignatureSpan">(position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chunkAtPosition = function (position) {
  var cubeSize = this.cubeSize;
  var x = Math.floor(position[0] / cubeSize)
  var y = Math.floor(position[1] / cubeSize)
  var z = Math.floor(position[2] / cubeSize)
  var chunkPos = this.chunkAtCoordinates(x, y, z)
  return chunkPos
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.chunkMask = (1 &#x3c;&#x3c; this.chunkBits) - 1
this.chunkPadHalf = this.chunkPad &#x3e;&#x3e; 1
}

inherits(Chunker, events.EventEmitter)

Chunker.prototype.nearbyChunks = function(position, distance) {
var current = this.<span class="apidocCodeKeywordSpan">chunkAtPosition</span>(position)
var x = current[0]
var y = current[1]
var z = current[2]
var dist = distance || this.distance
var nearby = []
for (var cx = (x - dist); cx !== (x + dist); ++cx) {
  for (var cy = (y - dist); cy !== (y + dist); ++cy) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.Chunker.prototype.generateChunk" id="apidoc.element.voxel.Chunker.prototype.generateChunk">
        function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>generateChunk
        <span class="apidocSignatureSpan">(x, y, z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateChunk = function (x, y, z) {
  var self = this
  var bounds = this.getBounds(x, y, z)
  var chunk = this.generateVoxelChunk(bounds[0], bounds[1], x, y, z)
  var position = [x, y, z]
  chunk.position = position
  this.chunks[position.join(&#x27;|&#x27;)] = chunk
  return chunk
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var chunker = voxel({chunkDistance: 2, chunkSize: 32, cubeSize: 1})
  t.deepEqual(chunker.nearbyChunks([0, 0, 0], 1), [[-1, -1, -1], [-1, -1, 0], [-1, 0, -1], [-1, 0, 0], [0, -1, -1], [0, -1, 0], [
0, 0, -1], [0, 0, 0]])
  t.end()
})

test(&#x27;generateChunk&#x27;, function (t) {
  var chunker = voxel({chunkDistance: 2, chunkSize: 32, cubeSize: 1})
  chunker.<span class="apidocCodeKeywordSpan">generateChunk</span>(0, 0, 0)
  t.equal(!!chunker.chunks[&#x27;0|0|0&#x27;], true)
  chunker.generateChunk(1, 0, 0)
  t.equal(!!chunker.chunks[&#x27;1|0|0&#x27;], true)
  chunker.generateChunk(-1, 0, 0)
  t.equal(!!chunker.chunks[&#x27;-1|0|0&#x27;], true)
  t.end()
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.Chunker.prototype.getBounds" id="apidoc.element.voxel.Chunker.prototype.getBounds">
        function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>getBounds
        <span class="apidocSignatureSpan">(x, y, z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBounds = function (x, y, z) {
  var bits = this.chunkBits
  var low = [x &#x3c;&#x3c; bits, y &#x3c;&#x3c; bits, z &#x3c;&#x3c; bits]
  var high = [(x+1) &#x3c;&#x3c; bits, (y+1) &#x3c;&#x3c; bits, (z+1) &#x3c;&#x3c; bits]
  return [low, high]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var low = [x &#x3c;&#x3c; bits, y &#x3c;&#x3c; bits, z &#x3c;&#x3c; bits]
  var high = [(x+1) &#x3c;&#x3c; bits, (y+1) &#x3c;&#x3c; bits, (z+1) &#x3c;&#x3c; bits]
  return [low, high]
}

Chunker.prototype.generateChunk = function(x, y, z) {
  var self = this
  var bounds = this.<span class="apidocCodeKeywordSpan">getBounds</span>(x, y, z)
  var chunk = this.generateVoxelChunk(bounds[0], bounds[1], x, y, z)
  var position = [x, y, z]
  chunk.position = position
  this.chunks[position.join(&#x27;|&#x27;)] = chunk
  return chunk
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.Chunker.prototype.nearbyChunks" id="apidoc.element.voxel.Chunker.prototype.nearbyChunks">
        function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>nearbyChunks
        <span class="apidocSignatureSpan">(position, distance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nearbyChunks = function (position, distance) {
  var current = this.chunkAtPosition(position)
  var x = current[0]
  var y = current[1]
  var z = current[2]
  var dist = distance || this.distance
  var nearby = []
  for (var cx = (x - dist); cx !== (x + dist); ++cx) {
    for (var cy = (y - dist); cy !== (y + dist); ++cy) {
      for (var cz = (z - dist); cz !== (z + dist); ++cz) {
        nearby.push([cx, cy, cz])
      }
    }
  }
  return nearby
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  return nearby
}

Chunker.prototype.requestMissingChunks = function(position) {
  var self = this
  this.<span class="apidocCodeKeywordSpan">nearbyChunks</span>(position).map(function(chunk) {
    if (!self.chunks[chunk.join(&#x27;|&#x27;)]) {
      self.emit(&#x27;missingChunk&#x27;, chunk)
    }
  })
}

Chunker.prototype.getBounds = function(x, y, z) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.Chunker.prototype.requestMissingChunks" id="apidoc.element.voxel.Chunker.prototype.requestMissingChunks">
        function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>requestMissingChunks
        <span class="apidocSignatureSpan">(position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requestMissingChunks = function (position) {
  var self = this
  this.nearbyChunks(position).map(function(chunk) {
    if (!self.chunks[chunk.join(&#x27;|&#x27;)]) {
      self.emit(&#x27;missingChunk&#x27;, chunk)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
chunker.generateChunk(0, 0, 0)
chunker.generateChunk(1, 0, 0)
chunker.generateChunk(-1, 0, 0)
var missing = []
chunker.on(&#x27;missingChunk&#x27;, function (pos) {
  missing.push(pos)
})
chunker.<span class="apidocCodeKeywordSpan">requestMissingChunks</span>([0, 0, 0])
t.deepEqual(missing, [[-1, -1, -1], [-1, -1, 0], [-1, 0, -1], [0, -1, -1], [0, -1, 0], [0, 0, -1]])
t.end()
})

test(&#x27;voxelAtCoordinates&#x27;, function (t) {
var chunker = voxel({chunkDistance: 2, chunkSize: 32, cubeSize: 1})
chunker.generateChunk(0, 0, 0)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.Chunker.prototype.voxelAtCoordinates" id="apidoc.element.voxel.Chunker.prototype.voxelAtCoordinates">
        function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>voxelAtCoordinates
        <span class="apidocSignatureSpan">(x, y, z, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">voxelAtCoordinates = function (x, y, z, val) {
  var ckey = this.chunkAtCoordinates(x, y, z).join(&#x27;|&#x27;)
  var chunk = this.chunks[ckey]
  if (!chunk) return false
  var mask = this.chunkMask
  var h = this.chunkPadHalf
  var mx = x &#x26; mask
  var my = y &#x26; mask
  var mz = z &#x26; mask
  var v = chunk.get(mx+h, my+h, mz+h)
  if (typeof val !== &#x27;undefined&#x27;) {
    chunk.set(mx+h, my+h, mz+h, val)
  }
  return v
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Chunker.prototype.voxelAtPosition = function(pos, val) {
  var cubeSize = this.cubeSize;
  var x = Math.floor(pos[0] / cubeSize)
  var y = Math.floor(pos[1] / cubeSize)
  var z = Math.floor(pos[2] / cubeSize)
  var v = this.<span class="apidocCodeKeywordSpan">voxelAtCoordinates</span>(x, y, z, val)
  return v;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.Chunker.prototype.voxelAtPosition" id="apidoc.element.voxel.Chunker.prototype.voxelAtPosition">
        function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>voxelAtPosition
        <span class="apidocSignatureSpan">(pos, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">voxelAtPosition = function (pos, val) {
  var cubeSize = this.cubeSize;
  var x = Math.floor(pos[0] / cubeSize)
  var y = Math.floor(pos[1] / cubeSize)
  var z = Math.floor(pos[2] / cubeSize)
  var v = this.voxelAtCoordinates(x, y, z, val)
  return v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  t.equal(chunker.voxelAtCoordinates(-1, 0, 0), false)
  t.end()
})

test(&#x27;voxelAtPosition&#x27;, function (t) {
  var chunker = voxel({chunkDistance: 2, chunkSize: 32, cubeSize: 1})
  chunker.generateChunk(0, 0, 0)
  t.equal(chunker.<span class="apidocCodeKeywordSpan">voxelAtPosition</span>([0, 16, 0], 1), 0)
  t.equal(chunker.voxelAtPosition([0, 16.9999, 0]), 1)
  t.end()
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.Chunker.prototype.voxelIndexFromCoordinates" id="apidoc.element.voxel.Chunker.prototype.voxelIndexFromCoordinates">
        function <span class="apidocSignatureSpan">voxel.Chunker.prototype.</span>voxelIndexFromCoordinates
        <span class="apidocSignatureSpan">(x, y, z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">voxelIndexFromCoordinates = function (x, y, z) {
  throw new Error(&#x27;Chunker.prototype.voxelIndexFromCoordinates removed, use voxelAtCoordinates&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voxel.chunker" id="apidoc.module.voxel.chunker">module voxel.chunker</a></h1>


    <h2>
        <a href="#apidoc.element.voxel.chunker.chunker" id="apidoc.element.voxel.chunker.chunker">
        function <span class="apidocSignatureSpan">voxel.</span>chunker
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chunker = function (opts) {
  return new Chunker(opts)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.chunker.Chunker" id="apidoc.element.voxel.chunker.Chunker">
        function <span class="apidocSignatureSpan">voxel.chunker.</span>Chunker
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chunker(opts) {
  this.distance = opts.chunkDistance || 2
  this.chunkSize = opts.chunkSize || 32
  this.chunkPad = opts.chunkPad !== undefined ? opts.chunkPad : 0
  this.cubeSize = opts.cubeSize || 25
  this.generateVoxelChunk = opts.generateVoxelChunk
  this.chunks = {}
  this.meshes = {}

  if (this.chunkSize &#x26; this.chunkSize-1 !== 0)
    throw new Error(&#x27;chunkSize must be a power of 2&#x27;)
  var bits = 0;
  for (var size = this.chunkSize; size &#x3e; 0; size &#x3e;&#x3e;= 1) bits++;
  this.chunkBits = bits - 1;
  this.chunkMask = (1 &#x3c;&#x3c; this.chunkBits) - 1
  this.chunkPadHalf = this.chunkPad &#x3e;&#x3e; 1
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voxel.culled" id="apidoc.module.voxel.culled">module voxel.culled</a></h1>


    <h2>
        <a href="#apidoc.element.voxel.culled.mesher" id="apidoc.element.voxel.culled.mesher">
        function <span class="apidocSignatureSpan">voxel.culled.</span>mesher
        <span class="apidocSignatureSpan">(volume, dims)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CulledMesh(volume, dims) {
  //Precalculate direction vectors for convenience
  var dir = new Array(3);
  for(var i=0; i&#x3c;3; ++i) {
    dir[i] = [[0,0,0], [0,0,0]];
    dir[i][0][(i+1)%3] = 1;
    dir[i][1][(i+2)%3] = 1;
  }
  //March over the volume
  var vertices = []
    , faces = []
    , x = [0,0,0]
    , B = [[false,true]    //Incrementally update bounds (this is a bit ugly)
          ,[false,true]
          ,[false,true]]
    , n = -dims[0]*dims[1];
  for(           B[2]=[false,true],x[2]=-1; x[2]&#x3c;dims[2]; B[2]=[true,(++x[2]&#x3c;dims[2]-1)])
  for(n-=dims[0],B[1]=[false,true],x[1]=-1; x[1]&#x3c;dims[1]; B[1]=[true,(++x[1]&#x3c;dims[1]-1)])
  for(n-=1,      B[0]=[false,true],x[0]=-1; x[0]&#x3c;dims[0]; B[0]=[true,(++x[0]&#x3c;dims[0]-1)], ++n) {
    //Read current voxel and 3 neighboring voxels using bounds check results
    var p =   (B[0][0] &#x26;&#x26; B[1][0] &#x26;&#x26; B[2][0]) ? volume[n]                 : 0
      , b = [ (B[0][1] &#x26;&#x26; B[1][0] &#x26;&#x26; B[2][0]) ? volume[n+1]               : 0
            , (B[0][0] &#x26;&#x26; B[1][1] &#x26;&#x26; B[2][0]) ? volume[n+dims[0]]         : 0
            , (B[0][0] &#x26;&#x26; B[1][0] &#x26;&#x26; B[2][1]) ? volume[n+dims[0]*dims[1]] : 0
          ];
    //Generate faces
    for(var d=0; d&#x3c;3; ++d)
    if((!!p) !== (!!b[d])) {
      var s = !p ? 1 : 0;
      var t = [x[0],x[1],x[2]]
        , u = dir[d][s]
        , v = dir[d][s^1];
      ++t[d];

      var vertex_count = vertices.length;
      vertices.push([t[0],           t[1],           t[2]          ]);
      vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);
      vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);
      vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);
      faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, s ? b[d] : p]);
    }
  }
  return { vertices:vertices, faces:faces };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voxel.generator" id="apidoc.module.voxel.generator">module voxel.generator</a></h1>


    <h2>
        <a href="#apidoc.element.voxel.generator.Checker" id="apidoc.element.voxel.generator.Checker">
        function <span class="apidocSignatureSpan">voxel.generator.</span>Checker
        <span class="apidocSignatureSpan">(i, j, k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Checker = function (i, j, k) {
  return !!((i+j+k)&#x26;1) ? (((i^j^k)&#x26;2) ? 1 : 0xffffff) : 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.generator.Hill" id="apidoc.element.voxel.generator.Hill">
        function <span class="apidocSignatureSpan">voxel.generator.</span>Hill
        <span class="apidocSignatureSpan">(i, j, k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Hill = function (i, j, k) {
  return j &#x3c;= 16 * Math.exp(-(i*i + k*k) / 64) ? 1 : 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.generator.Noise" id="apidoc.element.voxel.generator.Noise">
        function <span class="apidocSignatureSpan">voxel.generator.</span>Noise
        <span class="apidocSignatureSpan">(i, j, k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Noise = function (i, j, k) {
  return Math.random() &#x3c; 0.1 ? Math.random() * 0xffffff : 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.generator.Sphere" id="apidoc.element.voxel.generator.Sphere">
        function <span class="apidocSignatureSpan">voxel.generator.</span>Sphere
        <span class="apidocSignatureSpan">(i, j, k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Sphere = function (i, j, k) {
  return i*i+j*j+k*k &#x3c;= 16*16 ? 1 : 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.generator.Valley" id="apidoc.element.voxel.generator.Valley">
        function <span class="apidocSignatureSpan">voxel.generator.</span>Valley
        <span class="apidocSignatureSpan">(i, j, k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Valley = function (i, j, k) {
  return j &#x3c;= (i*i + k*k) * 31 / (32*32*2) + 1 ? 1 + (1&#x3c;&#x3c;15) : 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voxel.greedy" id="apidoc.module.voxel.greedy">module voxel.greedy</a></h1>


    <h2>
        <a href="#apidoc.element.voxel.greedy.mesher" id="apidoc.element.voxel.greedy.mesher">
        function <span class="apidocSignatureSpan">voxel.greedy.</span>mesher
        <span class="apidocSignatureSpan">(volume, dims)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mesher = function (volume, dims) {
  var vertices = [], faces = []
    , dimsX = dims[0]
    , dimsY = dims[1]
    , dimsXY = dimsX * dimsY;

  //Sweep over 3-axes
  for(var d=0; d&#x3c;3; ++d) {
    var i, j, k, l, w, W, h, n, c
      , u = (d+1)%3
      , v = (d+2)%3
      , x = [0,0,0]
      , q = [0,0,0]
      , du = [0,0,0]
      , dv = [0,0,0]
      , dimsD = dims[d]
      , dimsU = dims[u]
      , dimsV = dims[v]
      , qdimsX, qdimsXY
      , xd

    if (mask.length &#x3c; dimsU * dimsV) {
      mask = new Int32Array(dimsU * dimsV);
    }

    q[d] =  1;
    x[d] = -1;

    qdimsX  = dimsX  * q[1]
    qdimsXY = dimsXY * q[2]

    // Compute mask
    while (x[d] &#x3c; dimsD) {
      xd = x[d]
      n = 0;

      for(x[v] = 0; x[v] &#x3c; dimsV; ++x[v]) {
        for(x[u] = 0; x[u] &#x3c; dimsU; ++x[u], ++n) {
          var a = xd &#x3e;= 0      &#x26;&#x26; volume[x[0]      + dimsX * x[1]          + dimsXY * x[2]          ]
            , b = xd &#x3c; dimsD-1 &#x26;&#x26; volume[x[0]+q[0] + dimsX * x[1] + qdimsX + dimsXY * x[2] + qdimsXY]
          if (a ? b : !b) {
            mask[n] = 0; continue;
          }
          mask[n] = a ? a : -b;
        }
      }

      ++x[d];

      // Generate mesh for mask using lexicographic ordering
      n = 0;
      for (j=0; j &#x3c; dimsV; ++j) {
        for (i=0; i &#x3c; dimsU; ) {
          c = mask[n];
          if (!c) {
            i++;  n++; continue;
          }

          //Compute width
          w = 1;
          while (c === mask[n+w] &#x26;&#x26; i+w &#x3c; dimsU) w++;

          //Compute height (this is slightly awkward)
          for (h=1; j+h &#x3c; dimsV; ++h) {
            k = 0;
            while (k &#x3c; w &#x26;&#x26; c === mask[n+k+h*dimsU]) k++
            if (k &#x3c; w) break;
          }

          // Add quad
          // The du/dv arrays are reused/reset
          // for each iteration.
          du[d] = 0; dv[d] = 0;
          x[u]  = i;  x[v] = j;

          if (c &#x3e; 0) {
            dv[v] = h; dv[u] = 0;
            du[u] = w; du[v] = 0;
          } else {
            c = -c;
            du[v] = h; du[u] = 0;
            dv[u] = w; dv[v] = 0;
          }
          var vertex_count = vertices.length;
          vertices.push([x[0],             x[1],             x[2]            ]);
          vertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);
          vertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);
          vertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);
          faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, c]);

          //Zero-out mask
          W = n + w;
          for(l=0; l&#x3c;h; ++l) {
            for(k=n; k&#x3c;W; ++k) {
              mask[k+l*dimsU] = 0;
            }
          }

          //Increment counters and continue
          i += w; n += w;
        }
      }
    }
  }
  return { vertices:vertices, faces:faces };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voxel.meshers" id="apidoc.module.voxel.meshers">module voxel.meshers</a></h1>


    <h2>
        <a href="#apidoc.element.voxel.meshers.culled" id="apidoc.element.voxel.meshers.culled">
        function <span class="apidocSignatureSpan">voxel.meshers.</span>culled
        <span class="apidocSignatureSpan">(volume, dims)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CulledMesh(volume, dims) {
  //Precalculate direction vectors for convenience
  var dir = new Array(3);
  for(var i=0; i&#x3c;3; ++i) {
    dir[i] = [[0,0,0], [0,0,0]];
    dir[i][0][(i+1)%3] = 1;
    dir[i][1][(i+2)%3] = 1;
  }
  //March over the volume
  var vertices = []
    , faces = []
    , x = [0,0,0]
    , B = [[false,true]    //Incrementally update bounds (this is a bit ugly)
          ,[false,true]
          ,[false,true]]
    , n = -dims[0]*dims[1];
  for(           B[2]=[false,true],x[2]=-1; x[2]&#x3c;dims[2]; B[2]=[true,(++x[2]&#x3c;dims[2]-1)])
  for(n-=dims[0],B[1]=[false,true],x[1]=-1; x[1]&#x3c;dims[1]; B[1]=[true,(++x[1]&#x3c;dims[1]-1)])
  for(n-=1,      B[0]=[false,true],x[0]=-1; x[0]&#x3c;dims[0]; B[0]=[true,(++x[0]&#x3c;dims[0]-1)], ++n) {
    //Read current voxel and 3 neighboring voxels using bounds check results
    var p =   (B[0][0] &#x26;&#x26; B[1][0] &#x26;&#x26; B[2][0]) ? volume[n]                 : 0
      , b = [ (B[0][1] &#x26;&#x26; B[1][0] &#x26;&#x26; B[2][0]) ? volume[n+1]               : 0
            , (B[0][0] &#x26;&#x26; B[1][1] &#x26;&#x26; B[2][0]) ? volume[n+dims[0]]         : 0
            , (B[0][0] &#x26;&#x26; B[1][0] &#x26;&#x26; B[2][1]) ? volume[n+dims[0]*dims[1]] : 0
          ];
    //Generate faces
    for(var d=0; d&#x3c;3; ++d)
    if((!!p) !== (!!b[d])) {
      var s = !p ? 1 : 0;
      var t = [x[0],x[1],x[2]]
        , u = dir[d][s]
        , v = dir[d][s^1];
      ++t[d];

      var vertex_count = vertices.length;
      vertices.push([t[0],           t[1],           t[2]          ]);
      vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);
      vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);
      vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);
      faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, s ? b[d] : p]);
    }
  }
  return { vertices:vertices, faces:faces };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.meshers.greedy" id="apidoc.element.voxel.meshers.greedy">
        function <span class="apidocSignatureSpan">voxel.meshers.</span>greedy
        <span class="apidocSignatureSpan">(volume, dims)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">greedy = function (volume, dims) {
  var vertices = [], faces = []
    , dimsX = dims[0]
    , dimsY = dims[1]
    , dimsXY = dimsX * dimsY;

  //Sweep over 3-axes
  for(var d=0; d&#x3c;3; ++d) {
    var i, j, k, l, w, W, h, n, c
      , u = (d+1)%3
      , v = (d+2)%3
      , x = [0,0,0]
      , q = [0,0,0]
      , du = [0,0,0]
      , dv = [0,0,0]
      , dimsD = dims[d]
      , dimsU = dims[u]
      , dimsV = dims[v]
      , qdimsX, qdimsXY
      , xd

    if (mask.length &#x3c; dimsU * dimsV) {
      mask = new Int32Array(dimsU * dimsV);
    }

    q[d] =  1;
    x[d] = -1;

    qdimsX  = dimsX  * q[1]
    qdimsXY = dimsXY * q[2]

    // Compute mask
    while (x[d] &#x3c; dimsD) {
      xd = x[d]
      n = 0;

      for(x[v] = 0; x[v] &#x3c; dimsV; ++x[v]) {
        for(x[u] = 0; x[u] &#x3c; dimsU; ++x[u], ++n) {
          var a = xd &#x3e;= 0      &#x26;&#x26; volume[x[0]      + dimsX * x[1]          + dimsXY * x[2]          ]
            , b = xd &#x3c; dimsD-1 &#x26;&#x26; volume[x[0]+q[0] + dimsX * x[1] + qdimsX + dimsXY * x[2] + qdimsXY]
          if (a ? b : !b) {
            mask[n] = 0; continue;
          }
          mask[n] = a ? a : -b;
        }
      }

      ++x[d];

      // Generate mesh for mask using lexicographic ordering
      n = 0;
      for (j=0; j &#x3c; dimsV; ++j) {
        for (i=0; i &#x3c; dimsU; ) {
          c = mask[n];
          if (!c) {
            i++;  n++; continue;
          }

          //Compute width
          w = 1;
          while (c === mask[n+w] &#x26;&#x26; i+w &#x3c; dimsU) w++;

          //Compute height (this is slightly awkward)
          for (h=1; j+h &#x3c; dimsV; ++h) {
            k = 0;
            while (k &#x3c; w &#x26;&#x26; c === mask[n+k+h*dimsU]) k++
            if (k &#x3c; w) break;
          }

          // Add quad
          // The du/dv arrays are reused/reset
          // for each iteration.
          du[d] = 0; dv[d] = 0;
          x[u]  = i;  x[v] = j;

          if (c &#x3e; 0) {
            dv[v] = h; dv[u] = 0;
            du[u] = w; du[v] = 0;
          } else {
            c = -c;
            du[v] = h; du[u] = 0;
            dv[u] = w; dv[v] = 0;
          }
          var vertex_count = vertices.length;
          vertices.push([x[0],             x[1],             x[2]            ]);
          vertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);
          vertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);
          vertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);
          faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, c]);

          //Zero-out mask
          W = n + w;
          for(l=0; l&#x3c;h; ++l) {
            for(k=n; k&#x3c;W; ++k) {
              mask[k+l*dimsU] = 0;
            }
          }

          //Increment counters and continue
          i += w; n += w;
        }
      }
    }
  }
  return { vertices:vertices, faces:faces };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.meshers.monotone" id="apidoc.element.voxel.meshers.monotone">
        function <span class="apidocSignatureSpan">voxel.meshers.</span>monotone
        <span class="apidocSignatureSpan">(volume, dims)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">monotone = function (volume, dims) {
  function f(i,j,k) {
    return volume[i + dims[0] * (j + dims[1] * k)];
  }
  //Sweep over 3-axes
  var vertices = [], faces = [];
  for(var d=0; d&#x3c;3; ++d) {
    var i, j, k
      , u = (d+1)%3   //u and v are orthogonal directions to d
      , v = (d+2)%3
      , x = new Int32Array(3)
      , q = new Int32Array(3)
      , runs = new Int32Array(2 * (dims[u]+1))
      , frontier = new Int32Array(dims[u])  //Frontier is list of pointers to polygons
      , next_frontier = new Int32Array(dims[u])
      , left_index = new Int32Array(2 * dims[v])
      , right_index = new Int32Array(2 * dims[v])
      , stack = new Int32Array(24 * dims[v])
      , delta = [[0,0], [0,0]];
    //q points along d-direction
    q[d] = 1;
    //Initialize sentinel
    for(x[d]=-1; x[d]&#x3c;dims[d]; ) {
      // --- Perform monotone polygon subdivision ---
      var n = 0
        , polygons = []
        , nf = 0;
      for(x[v]=0; x[v]&#x3c;dims[v]; ++x[v]) {
        //Make one pass over the u-scan line of the volume to run-length encode polygon
        var nr = 0, p = 0, c = 0;
        for(x[u]=0; x[u]&#x3c;dims[u]; ++x[u], p = c) {
          //Compute the type for this face
          var a = (0    &#x3c;= x[d]      ? f(x[0],      x[1],      x[2])      : 0)
            , b = (x[d] &#x3c;  dims[d]-1 ? f(x[0]+q[0], x[1]+q[1], x[2]+q[2]) : 0);
          c = a;
          if((!a) === (!b)) {
            c = 0;
          } else if(!a) {
            c = -b;
          }
          //If cell type doesn&#x27;t match, start a new run
          if(p !== c) {
            runs[nr++] = x[u];
            runs[nr++] = c;
          }
        }
        //Add sentinel run
        runs[nr++] = dims[u];
        runs[nr++] = 0;
        //Update frontier by merging runs
        var fp = 0;
        for(var i=0, j=0; i&#x3c;nf &#x26;&#x26; j&#x3c;nr-2; ) {
          var p    = polygons[frontier[i]]
            , p_l  = p.left[p.left.length-1][0]
            , p_r  = p.right[p.right.length-1][0]
            , p_c  = p.color
            , r_l  = runs[j]    //Start of run
            , r_r  = runs[j+2]  //End of run
            , r_c  = runs[j+1]; //Color of run
          //Check if we can merge run with polygon
          if(r_r &#x3e; p_l &#x26;&#x26; p_r &#x3e; r_l &#x26;&#x26; r_c === p_c) {
            //Merge run
            p.merge_run(x[v], r_l, r_r);
            //Insert polygon into frontier
            next_frontier[fp++] = frontier[i];
            ++i;
            j += 2;
          } else {
            //Check if we need to advance the run pointer
            if(r_r &#x3c;= p_r) {
              if(!!r_c) {
                var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);
                next_frontier[fp++] = polygons.length;
                polygons.push(n_poly);
              }
              j += 2;
            }
            //Check if we need to advance the frontier pointer
            if(p_r &#x3c;= r_r) {
              p.close_off(x[v]);
              ++i;
            }
          }
        }
        //Close off any residual polygons
        for(; i&#x3c;nf; ++i) {
          polygons[frontier[i]].close_off(x[v]);
        }
        //Add any extra runs to frontier
        for(; j&#x3c;nr-2; j+=2) {
          var r_l  = runs[j]
            , r_r  = runs[j+2]
            , r_c  = runs[j+1];
          if(!!r_c) {
            var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);
            next_frontier[fp++] = polygons.length;
            polygons.push(n_poly);
          }
        }
        //Swap frontiers
        var tmp = next_frontier;
        next_frontier = frontier;
        frontier = tmp;
        nf = fp;
      }
      //Close off frontier
      for(var i=0; i&#x3c;nf; ++i) {
        var p = polygons[frontier[i]];
        p.close_off(dims[v]);
      }
      // --- Monotone subdivision of polygon is complete at this point ---

      x[d]++;

      //Now we just need to triangulate each monotone polygon
      for(var i=0; i&#x3c;polygons.length; ++i) {
        var p = polygons[i]
          , c = p.color
          , flipped = false;
        if(c &#x3c; 0) {
          flipped = true;
          c = -c;
        }
        for(var j ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.meshers.stupid" id="apidoc.element.voxel.meshers.stupid">
        function <span class="apidocSignatureSpan">voxel.meshers.</span>stupid
        <span class="apidocSignatureSpan">(volume, dims)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StupidMesh(volume, dims) {
  var vertices = [], faces = [], x = [0,0,0], n = 0;
  for(x[2]=0; x[2]&#x3c;dims[2]; ++x[2])
  for(x[1]=0; x[1]&#x3c;dims[1]; ++x[1])
  for(x[0]=0; x[0]&#x3c;dims[0]; ++x[0], ++n)
  if(!!volume[n]) {
    for(var d=0; d&#x3c;3; ++d) {
      var t = [x[0], x[1], x[2]]
        , u = [0,0,0]
        , v = [0,0,0];
      u[(d+1)%3] = 1;
      v[(d+2)%3] = 1;
      for(var s=0; s&#x3c;2; ++s) {
        t[d] = x[d] + s;
        var tmp = u;
        u = v;
        v = tmp;
        var vertex_count = vertices.length;
        vertices.push([t[0],           t[1],           t[2]          ]);
        vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);
        vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);
        vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);
        faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, volume[n]]);
      }
    }
  }
  return { vertices:vertices, faces:faces };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.voxel.meshers.transgreedy" id="apidoc.element.voxel.meshers.transgreedy">
        function <span class="apidocSignatureSpan">voxel.meshers.</span>transgreedy
        <span class="apidocSignatureSpan">(volume, dims, mesherExtraData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ohSoGreedyMesher(volume, dims, mesherExtraData) {
  var vertices = [], faces = []
    , dimsX = dims[0]
    , dimsY = dims[1]
    , dimsXY = dimsX * dimsY;

  var tVertices = [], tFaces = []

  var transparentTypes = mesherExtraData ? (mesherExtraData.transparentTypes || {}) : {};
  var getType = function(voxels, offset) {
    var type = voxels[offset];
    return type | (type in transparentTypes ? kTransparentMask : 0);
  }


  //Sweep over 3-axes
  for(var d=0; d&#x3c;3; ++d) {
    var i, j, k, l, w, W, h, n, c
      , u = (d+1)%3
      , v = (d+2)%3
      , x = [0,0,0]
      , q = [0,0,0]
      , du = [0,0,0]
      , dv = [0,0,0]
      , dimsD = dims[d]
      , dimsU = dims[u]
      , dimsV = dims[v]
      , qdimsX, qdimsXY
      , xd

    if (mask.length &#x3c; dimsU * dimsV) {
      mask = new Int32Array(dimsU * dimsV);
      invMask = new Int32Array(dimsU * dimsV);
    }

    q[d] =  1;
    x[d] = -1;

    qdimsX  = dimsX  * q[1]
    qdimsXY = dimsXY * q[2]

    // Compute mask
    while (x[d] &#x3c; dimsD) {
      xd = x[d]
      n = 0;

      for(x[v] = 0; x[v] &#x3c; dimsV; ++x[v]) {
        for(x[u] = 0; x[u] &#x3c; dimsU; ++x[u], ++n) {
          // Modified to read through getType()
          var a = xd &#x3e;= 0      &#x26;&#x26; getType(volume, x[0]      + dimsX * x[1]          + dimsXY * x[2]          )
            , b = xd &#x3c; dimsD-1 &#x26;&#x26; getType(volume, x[0]+q[0] + dimsX * x[1] + qdimsX + dimsXY * x[2] + qdimsXY)

          // both are transparent, add to both directions
          if (isTransparent(a) &#x26;&#x26; isTransparent(b)) {
            mask[n] = a;
            invMask[n] = b;
          // if a is solid and b is not there or transparent
          } else if (a &#x26;&#x26; (!b || isTransparent(b))) {
            mask[n] = a;
            invMask[n] = 0
          // if b is solid and a is not there or transparent
          } else if (b &#x26;&#x26; (!a || isTransparent(a))) {
            mask[n] = 0
            invMask[n] = b;
          // dont draw this face
          } else {
            mask[n] = 0
            invMask[n] = 0
          }
        }
      }

      ++x[d];

      // Generate mesh for mask using lexicographic ordering
      function generateMesh(mask, dimsV, dimsU, vertices, faces, clockwise) {
        clockwise = clockwise === undefined ? true : clockwise;
        var n, j, i, c, w, h, k, du = [0,0,0], dv = [0,0,0];
        n = 0;
        for (j=0; j &#x3c; dimsV; ++j) {
          for (i=0; i &#x3c; dimsU; ) {
            c = mask[n];
            if (!c) {
              i++;  n++; continue;
            }

            //Compute width
            w = 1;
            while (c === mask[n+w] &#x26;&#x26; i+w &#x3c; dimsU) w++;

            //Compute height (this is slightly awkward)
            for (h=1; j+h &#x3c; dimsV; ++h) {
              k = 0;
              while (k &#x3c; w &#x26;&#x26; c === mask[n+k+h*dimsU]) k++
              if (k &#x3c; w) break;
            }

            // Add quad
            // The du/dv arrays are reused/reset
            // for each iteration.
            du[d] = 0; dv[d] = 0;
            x[u]  = i;  x[v] = j;

            if (clockwise) {
            // if (c &#x3e; 0) {
              dv[v] = h; dv[u] = 0;
              du[u] = w; du[v] = 0;
            } else {
              // c = -c;
              du[v] = h; du[u] = 0;
              dv[u] = w; dv[v] = 0;
            }

            // ## enable code to ensure that transparent faces are last in the list
            // if (!isTransparent(c)) {
              var vertex_count = vertices.length;
              vertices.push([x[0],             x[1],             x[2]            ]);
              vertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);
              vertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);
              vertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);
              faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, removeFlags(c)]);
            // } else {
            //   var vertex_count = tVertices.length;
            //   tVertices.push([x[0],             x[1],             x[2]            ]);
            / ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voxel.monotone" id="apidoc.module.voxel.monotone">module voxel.monotone</a></h1>


    <h2>
        <a href="#apidoc.element.voxel.monotone.mesher" id="apidoc.element.voxel.monotone.mesher">
        function <span class="apidocSignatureSpan">voxel.monotone.</span>mesher
        <span class="apidocSignatureSpan">(volume, dims)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mesher = function (volume, dims) {
  function f(i,j,k) {
    return volume[i + dims[0] * (j + dims[1] * k)];
  }
  //Sweep over 3-axes
  var vertices = [], faces = [];
  for(var d=0; d&#x3c;3; ++d) {
    var i, j, k
      , u = (d+1)%3   //u and v are orthogonal directions to d
      , v = (d+2)%3
      , x = new Int32Array(3)
      , q = new Int32Array(3)
      , runs = new Int32Array(2 * (dims[u]+1))
      , frontier = new Int32Array(dims[u])  //Frontier is list of pointers to polygons
      , next_frontier = new Int32Array(dims[u])
      , left_index = new Int32Array(2 * dims[v])
      , right_index = new Int32Array(2 * dims[v])
      , stack = new Int32Array(24 * dims[v])
      , delta = [[0,0], [0,0]];
    //q points along d-direction
    q[d] = 1;
    //Initialize sentinel
    for(x[d]=-1; x[d]&#x3c;dims[d]; ) {
      // --- Perform monotone polygon subdivision ---
      var n = 0
        , polygons = []
        , nf = 0;
      for(x[v]=0; x[v]&#x3c;dims[v]; ++x[v]) {
        //Make one pass over the u-scan line of the volume to run-length encode polygon
        var nr = 0, p = 0, c = 0;
        for(x[u]=0; x[u]&#x3c;dims[u]; ++x[u], p = c) {
          //Compute the type for this face
          var a = (0    &#x3c;= x[d]      ? f(x[0],      x[1],      x[2])      : 0)
            , b = (x[d] &#x3c;  dims[d]-1 ? f(x[0]+q[0], x[1]+q[1], x[2]+q[2]) : 0);
          c = a;
          if((!a) === (!b)) {
            c = 0;
          } else if(!a) {
            c = -b;
          }
          //If cell type doesn&#x27;t match, start a new run
          if(p !== c) {
            runs[nr++] = x[u];
            runs[nr++] = c;
          }
        }
        //Add sentinel run
        runs[nr++] = dims[u];
        runs[nr++] = 0;
        //Update frontier by merging runs
        var fp = 0;
        for(var i=0, j=0; i&#x3c;nf &#x26;&#x26; j&#x3c;nr-2; ) {
          var p    = polygons[frontier[i]]
            , p_l  = p.left[p.left.length-1][0]
            , p_r  = p.right[p.right.length-1][0]
            , p_c  = p.color
            , r_l  = runs[j]    //Start of run
            , r_r  = runs[j+2]  //End of run
            , r_c  = runs[j+1]; //Color of run
          //Check if we can merge run with polygon
          if(r_r &#x3e; p_l &#x26;&#x26; p_r &#x3e; r_l &#x26;&#x26; r_c === p_c) {
            //Merge run
            p.merge_run(x[v], r_l, r_r);
            //Insert polygon into frontier
            next_frontier[fp++] = frontier[i];
            ++i;
            j += 2;
          } else {
            //Check if we need to advance the run pointer
            if(r_r &#x3c;= p_r) {
              if(!!r_c) {
                var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);
                next_frontier[fp++] = polygons.length;
                polygons.push(n_poly);
              }
              j += 2;
            }
            //Check if we need to advance the frontier pointer
            if(p_r &#x3c;= r_r) {
              p.close_off(x[v]);
              ++i;
            }
          }
        }
        //Close off any residual polygons
        for(; i&#x3c;nf; ++i) {
          polygons[frontier[i]].close_off(x[v]);
        }
        //Add any extra runs to frontier
        for(; j&#x3c;nr-2; j+=2) {
          var r_l  = runs[j]
            , r_r  = runs[j+2]
            , r_c  = runs[j+1];
          if(!!r_c) {
            var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);
            next_frontier[fp++] = polygons.length;
            polygons.push(n_poly);
          }
        }
        //Swap frontiers
        var tmp = next_frontier;
        next_frontier = frontier;
        frontier = tmp;
        nf = fp;
      }
      //Close off frontier
      for(var i=0; i&#x3c;nf; ++i) {
        var p = polygons[frontier[i]];
        p.close_off(dims[v]);
      }
      // --- Monotone subdivision of polygon is complete at this point ---

      x[d]++;

      //Now we just need to triangulate each monotone polygon
      for(var i=0; i&#x3c;polygons.length; ++i) {
        var p = polygons[i]
          , c = p.color
          , flipped = false;
        if(c &#x3c; 0) {
          flipped = true;
          c = -c;
        }
        for(var j ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voxel.stupid" id="apidoc.module.voxel.stupid">module voxel.stupid</a></h1>


    <h2>
        <a href="#apidoc.element.voxel.stupid.mesher" id="apidoc.element.voxel.stupid.mesher">
        function <span class="apidocSignatureSpan">voxel.stupid.</span>mesher
        <span class="apidocSignatureSpan">(volume, dims)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StupidMesh(volume, dims) {
  var vertices = [], faces = [], x = [0,0,0], n = 0;
  for(x[2]=0; x[2]&#x3c;dims[2]; ++x[2])
  for(x[1]=0; x[1]&#x3c;dims[1]; ++x[1])
  for(x[0]=0; x[0]&#x3c;dims[0]; ++x[0], ++n)
  if(!!volume[n]) {
    for(var d=0; d&#x3c;3; ++d) {
      var t = [x[0], x[1], x[2]]
        , u = [0,0,0]
        , v = [0,0,0];
      u[(d+1)%3] = 1;
      v[(d+2)%3] = 1;
      for(var s=0; s&#x3c;2; ++s) {
        t[d] = x[d] + s;
        var tmp = u;
        u = v;
        v = tmp;
        var vertex_count = vertices.length;
        vertices.push([t[0],           t[1],           t[2]          ]);
        vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);
        vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);
        vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);
        faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, volume[n]]);
      }
    }
  }
  return { vertices:vertices, faces:faces };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.voxel.transgreedy" id="apidoc.module.voxel.transgreedy">module voxel.transgreedy</a></h1>


    <h2>
        <a href="#apidoc.element.voxel.transgreedy.mesher" id="apidoc.element.voxel.transgreedy.mesher">
        function <span class="apidocSignatureSpan">voxel.transgreedy.</span>mesher
        <span class="apidocSignatureSpan">(volume, dims, mesherExtraData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ohSoGreedyMesher(volume, dims, mesherExtraData) {
  var vertices = [], faces = []
    , dimsX = dims[0]
    , dimsY = dims[1]
    , dimsXY = dimsX * dimsY;

  var tVertices = [], tFaces = []

  var transparentTypes = mesherExtraData ? (mesherExtraData.transparentTypes || {}) : {};
  var getType = function(voxels, offset) {
    var type = voxels[offset];
    return type | (type in transparentTypes ? kTransparentMask : 0);
  }


  //Sweep over 3-axes
  for(var d=0; d&#x3c;3; ++d) {
    var i, j, k, l, w, W, h, n, c
      , u = (d+1)%3
      , v = (d+2)%3
      , x = [0,0,0]
      , q = [0,0,0]
      , du = [0,0,0]
      , dv = [0,0,0]
      , dimsD = dims[d]
      , dimsU = dims[u]
      , dimsV = dims[v]
      , qdimsX, qdimsXY
      , xd

    if (mask.length &#x3c; dimsU * dimsV) {
      mask = new Int32Array(dimsU * dimsV);
      invMask = new Int32Array(dimsU * dimsV);
    }

    q[d] =  1;
    x[d] = -1;

    qdimsX  = dimsX  * q[1]
    qdimsXY = dimsXY * q[2]

    // Compute mask
    while (x[d] &#x3c; dimsD) {
      xd = x[d]
      n = 0;

      for(x[v] = 0; x[v] &#x3c; dimsV; ++x[v]) {
        for(x[u] = 0; x[u] &#x3c; dimsU; ++x[u], ++n) {
          // Modified to read through getType()
          var a = xd &#x3e;= 0      &#x26;&#x26; getType(volume, x[0]      + dimsX * x[1]          + dimsXY * x[2]          )
            , b = xd &#x3c; dimsD-1 &#x26;&#x26; getType(volume, x[0]+q[0] + dimsX * x[1] + qdimsX + dimsXY * x[2] + qdimsXY)

          // both are transparent, add to both directions
          if (isTransparent(a) &#x26;&#x26; isTransparent(b)) {
            mask[n] = a;
            invMask[n] = b;
          // if a is solid and b is not there or transparent
          } else if (a &#x26;&#x26; (!b || isTransparent(b))) {
            mask[n] = a;
            invMask[n] = 0
          // if b is solid and a is not there or transparent
          } else if (b &#x26;&#x26; (!a || isTransparent(a))) {
            mask[n] = 0
            invMask[n] = b;
          // dont draw this face
          } else {
            mask[n] = 0
            invMask[n] = 0
          }
        }
      }

      ++x[d];

      // Generate mesh for mask using lexicographic ordering
      function generateMesh(mask, dimsV, dimsU, vertices, faces, clockwise) {
        clockwise = clockwise === undefined ? true : clockwise;
        var n, j, i, c, w, h, k, du = [0,0,0], dv = [0,0,0];
        n = 0;
        for (j=0; j &#x3c; dimsV; ++j) {
          for (i=0; i &#x3c; dimsU; ) {
            c = mask[n];
            if (!c) {
              i++;  n++; continue;
            }

            //Compute width
            w = 1;
            while (c === mask[n+w] &#x26;&#x26; i+w &#x3c; dimsU) w++;

            //Compute height (this is slightly awkward)
            for (h=1; j+h &#x3c; dimsV; ++h) {
              k = 0;
              while (k &#x3c; w &#x26;&#x26; c === mask[n+k+h*dimsU]) k++
              if (k &#x3c; w) break;
            }

            // Add quad
            // The du/dv arrays are reused/reset
            // for each iteration.
            du[d] = 0; dv[d] = 0;
            x[u]  = i;  x[v] = j;

            if (clockwise) {
            // if (c &#x3e; 0) {
              dv[v] = h; dv[u] = 0;
              du[u] = w; du[v] = 0;
            } else {
              // c = -c;
              du[v] = h; du[u] = 0;
              dv[u] = w; dv[v] = 0;
            }

            // ## enable code to ensure that transparent faces are last in the list
            // if (!isTransparent(c)) {
              var vertex_count = vertices.length;
              vertices.push([x[0],             x[1],             x[2]            ]);
              vertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);
              vertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);
              vertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);
              faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, removeFlags(c)]);
            // } else {
            //   var vertex_count = tVertices.length;
            //   tVertices.push([x[0],             x[1],             x[2]            ]);
            / ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
